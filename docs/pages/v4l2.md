# V4L2 Documentation

## Version History

| Date [DD/MM/YY] | Comment | Version |
| --- | --- | --- |
| 08/08/23 | First Release | 1.0.0 |

## Table of Contents

- [Description](#description)
  - [Introduction](#introduction)
  - [Acronyms, Terms and Abbreviations](#acronyms-terms-and-abbreviations)
  - [References](#references)
- [Component Runtime Execution Requirements](#component-runtime-execution-requirements)
  - [Initialization and Startup](#initializatio-and-startup)
  - [Threading Model](#threading-model)
  - [Process Model](#process-model)
  - [Memory Model](#memory-model)
  - [Power Management Requirements](#power-management-requirements)
  - [Asynchronous Notification Model](#asynchronous-notification-model)
  - [Blocking calls](#blocking-calls)
  - [Internal Error Handling](#internal-error-handling)
  - [Persistence Model](#persistence-model)
- [Non-functional requirements](#non-functional-requirements)
  - [Logging and debugging requirements](#logging-and-debugging-requirements)
  - [Memory and performance requirements](#memory-and-performance-requirements)
  - [Quality Control](#quality-control)
  - [Licensing](#licensing)
  - [Build Requirements](#build-requirements)
  - [Variability Management](#variability-management)
  - [Platform or Product Customization](#platform-or-product-customization)
- [Interface API Documentation](#interface-api-documentation)
  - [Theory of operation and key concepts](#theory-of-operation-and-key-concepts)
  - [V4L2 IOCTL for SOC Implementation](#v4l2-ioctl-for-soc-implementation)
  - [Diagrams](#diagrams)
   - [IOCTL callflow during capturing images](#ioctl-callflow-during-capturing-images)
  - [Data Structures and Defines](#data-structures-and-defines)


## Description
This interface provides a set of `IOCTL` calls that are required to be supported by the `SoC`'s `V4L2` driver. Any of the layers calling the `V4L2`, should be referred as `Caller`.  
The diagram below shows the interaction between `Caller` and `SoC` `V4L2` Driver.

```mermaid
flowchart TD
A(Caller) --> |IOCTL calls| B(SoC V4L2 driver)

style A fill:#99CCFF,stroke:#333
style B fill:#fcc,stroke:#333
```

### Introduction
The `V4L2` functionality enables video playback applications to easily display video content on a variety of embedded Linux devices with different video output capabilities. `V4L2` framework provides a standardized and flexible interface for working with video devices on Linux-based systems. By providing a common API for accessing and controlling video devices, `V4L2` simplifies the development of video applications and drivers, and enables interoperability across different hardware platforms and drivers.

For example, when a user-space application requests a video frame, the `V4L2` driver captures the frame from the device using the configured communication channels and stores it in a buffer. The user-space application can then read the frame from the buffer and process it as needed. Similarly, when a user-space application requests output to a display device, the V4L2 driver outputs the video frames to the appropriate destination. During video playback, the video frames are sent to the video output device using the `V4L2` `IOCTL` calls, which handles the low-level details of displaying the frames on the screen.

### Acronyms, Terms and Abbreviations

- `HAL`    - Hardware Abstraction Layer
- `API`    - Application Programming Interface
- `Caller` - Any user of the interface via the IOCTLs
- `SoC`    - System on Chip
- `V4L2`   - Video For Linux version 2
- `IOCTL`  - Input-Output Control

### References
Video4Linux Devices Specifications - [Video4Linux devices](https://www.kernel.org/doc/html/v5.4/media/kapi/v4l2-core.html)


## Component Runtime Execution Requirements
These requirements ensure that the `HAL` executes correctly within the run-time environment that it will be used in. Failure to meet these requirements will likely result in undefined and unexpected behaviour.

### Initialization and Startup
The `V4L2` driver provides the interface between the `Caller` and the video device. Once the `Caller` successfully opens the video device file (available as /dev/videoX; where X is a non-negative integer) with read and write permissions (O_RDWR) using the `open`() system call and sets the O_CLOEXEC flag, it will then use subsequent `V4L2`-specific `IOCTL` calls to interact with the driver and perform operations. With `VIDIOC_QUERYCAP`() the `Caller` will get the device hardware capabilities.

### Threading Model
`HAL` is expected to be thread safe. Any `Caller` invoking the `API`s should ensure calls are made in a thread safe manner. There is no restriction on the vendor to create any number of threads to meet the operational requirements. 

### Process Model
This interface supports multiple instantiation with a single process. The `V4L2` driver is expected to support multiple opens. `EBUSY` will be returned if the driver does not support multiple opens and the device is already in use. Merely opening a `V4L2` device does not grant exclusive access. Initiating data exchange however assigns the right to read or write the requested type of data, and to change related properties, to this file descriptor. `Caller` can request additional access privileges using the priority mechanism. Refer: https://www.kernel.org/doc/html/next/userspace-api/media/v4l/open.html 

### Memory Model
The memory model of this interface needs to be taken care by the `SoC`'s `V4L2` driver only, with respect to the `IOCTL` calls which are required by the `Caller`. By utilizing these `IOCTL` calls, `Caller` will interact with `V4L2` and manage the memory model for video frames. The choice of memory type will be done by the `Caller` and `V4L2` driver should be able to support at least these two memory types: `V4L2_MEMORY_MMAP` and `V4L2_MEMORY_DMABUF`.

### Power Management Requirements
There is no requirement for the component to participate in power management. In general, the `SoC` `V4L2` driver should be designed to minimize the power consumption of the device.

### Asynchronous Notification Model
These three `API` calls, namely `VIDIOC_SUBSCRIBE_EVENT`, `VIDIOC_UNSUBSCRIBE_EVENT`, and `VIDIOC_DQEVENT`, support an asynchronous notification model as they enable the `Caller` to receive video events asynchronously, indicating changes or occurrences in the video device or system. Other `API`s primarily involve configuration, control, streaming, buffer management, or retrieval of information, but they do not have built-in mechanisms for asynchronous event handling or notifications.

1. `VIDIOC_SUBSCRIBE_EVENT`: This `API` call allows `Caller` to subscribe to video events generated by a video device asynchronously. Once subscribed, the `Caller` can receive notifications about specific events asynchronously, indicating changes or occurrences in the video device.

2. `VIDIOC_UNSUBSCRIBE_EVENT`: This `API` call cancels the subscription to video events previously established using `VIDIOC_SUBSCRIBE_EVENT`. It stops the asynchronous event notifications from being received by the `Caller`.

3. `VIDIOC_DQEVENT`: This `API` call dequeues a video event generated by a video device. It allows the `Caller` to retrieve the event information asynchronously, indicating the occurrence of a specific event.

The `V4L2` driver is required to support at least these four event types: `V4L2_EVENT_ALL`, `V4L2_EVENT_SRC_CH_RESOLUTION`, `V4L2_EVENT_SOURCE_CHANGE` and `V4L2_EVENT_EOS`. Refer: https://www.kernel.org/doc/html/v4.9/media/uapi/v4l/vidioc-dqevent.html#event-type

### Blocking calls
None of the calls in the interface should block.

### Internal Error Handling
All the `API`s must return error synchronously as a return argument. `HAL` is responsible for handling system errors (e.g. out of memory) internally.

### Persistence Model
There is no requirement for the interface to persist any setting information. 


## Non-functional requirements

### Logging and debugging requirements
This interface is required to support DEBUG, INFO and ERROR messages. ERROR logs should be enabled by default. DEBUG and INFO is required to be disabled by default and enabled when needed.

### Memory and performance requirements
This interface is required to not cause excessive memory and CPU utilization.

### Quality Control

- This interface is required to perform static analysis, our preferred tool is Coverity.
- Have a zero-warning policy with regards to compiling. All warnings are required to be treated as error.
- Copyright validation is required to be performed, e.g.: Black duck, FossID.
- Use of memory analysis tools like Valgrind are encouraged, to identify leaks/corruptions.
- `HAL` Tests will endeavour to create worst case scenarios to assist investigations.
- Improvements by any party to the testing suite are required to be fed back.

### Licensing
The `HAL` implementation is expected to released under the Apache License 2.0.

### Build Requirements
`V4L2` driver will be implemented as a kernel module. `SoC` team is expected to handle the compilation of `V4L2` driver as part of kernel and need to enable the configuration options required for adding `V4L2` driver in the kernel for supporting V4L protocol based decoding components. The driver modules plug into the videodev kernel module. Also, the driver's linux kernel is expected to be at least 5.4.0. Refer this link for necessary configuration options: https://www.kernelconfig.io/index.html

The build mechanism should be independent of Yocto.  

### Variability Management
Any changes in the `API`s should be reviewed and approved by the component architects. Further support may be added to test any specific requirements of the target platform or product.

### Platform or Product Customization
No product customization is expected from `SoC` vendors from this module. The `V4L2` test suite comes with a set of pre-defined test cases that cover a range of `V4L2` `IOCTL` calls. The test cases if are not sufficient for testing all the features of a specific platform or product then modification/customization of the test cases will be done by creating new test cases or modifying existing ones to better suit the requirements of the target platform or product.


## Interface API Documentation
`API` documentation will be provided by Doxygen which will be generated from the header files.

### Theory of operation and key concepts
The `Caller` is expected to have complete control over calling the `V4L2` `IOCTL`s.

- Operation of `V4L2` typically involves the following steps:

1. Device Detection and Opening: The `Caller` initiates the process by detecting (using `opendir`() & `readdir`() functions and creating full path) and attempting to open the video device file using the `open`() system call under the /dev/ directory. The operating system's file system layer handles the mapping of the specified device file to the corresponding driver. On success `open`() returns the new file descriptor. On error -1 is returned, and the `errno` variable is set appropriately.The `V4L2` driver, once accessed through the opened device file, provides the necessary interface for the `Caller` to communicate with the video device.

2. Device Capabilities Query: After opening the device, `Caller` shall query the `V4L2` framework for driver and hardware capabilities using `VIDIOC_QUERYCAP`. The `IOCTL` takes a pointer to a struct `v4l2_capability` which is filled by the driver. When the driver is not compatible with this specification the `IOCTL` returns an `EINVAL` error code. `SoC` `V4L2` driver is expected to support at least these device capabilities flags: `V4L2_CAP_DEVICE_CAPS`, `V4L2_CAP_STREAMING` and either `V4L2_CAP_VIDEO_M2M` or `V4L2_CAP_VIDEO_M2M_MPLANE`.

3. Stream Configuration: To prepare the video device for capturing video data, the `V4L2` interface configures various streaming parameters, such as the desired image format, buffer type and frame sizes. This step ensures that the video device is set up correctly for capturing video in the specified format.

4. Memory Mapping: `V4L2` provides memory mapping mechanisms to efficiently transfer video frames between the video device and the operating system. This process involves allocating memory buffers in the system, which will be used to store the captured video frames. `VIDIOC_QUERYBUF` is called and when buffer is ready, paste the buffer into the enqueue using `VIDIOC_QBUF`.

5. Stream Activation:  Once the device is properly configured and memory buffers are allocated, the `V4L2` interface activates the video stream using `VIDIOC_STREAMON`. This step starts the flow of video frames from the device to the allocated memory buffers, allowing the operating system to access and process the captured video data.

6. Data Processing and Utilization: Once the video stream is active, the operating system can retrieve the captured video frames from the memory buffers and process them for various purposes. This may include displaying the video feed on a screen using `VIDIOC_DQBUF`, saving the video to a file, performing real-time analysis, or integrating the video data into other applications.

- For `SoC` Implementation, `V4L2` driver is required to support these 23 `IOCTL` calls:

`VIDIOC_CROPCAP`, `VIDIOC_G_CTRL`, `VIDIOC_S_PARM`, `VIDIOC_QUERYCTRL`, `VIDIOC_S_CTRL`, `VIDIOC_STREAMOFF`, `VIDIOC_STREAMON`, `VIDIOC_DECODER_CMD`, `VIDIOC_QUERYCAP`, `VIDIOC_SUBSCRIBE_EVENT`, `VIDIOC_UNSUBSCRIBE_EVENT`, `VIDIOC_DQEVENT`, `VIDIOC_S_FMT`, `VIDIOC_G_FMT`, `VIDIOC_ENUM_FRAMESIZES`, `VIDIOC_ENUM_FMT`, `VIDIOC_QUERYBUF`, `VIDIOC_REQBUFS`, `VIDIOC_QBUF`, `VIDIOC_EXPBUF`, `VIDIOC_DQBUF`,`VIDIOC_G_SELECTION`, `VIDIOC_S_EXT_CTRLS`.

- Refer this link for function reference : https://www.kernel.org/doc/html/v5.4/media/uapi/v4l/user-func.html 

- `SoC` vendors can refer to the header file for `API` implementation here: https://git.linuxtv.org/v4l-utils.git/tree/include/linux/videodev2.h?h=stable-1.18


### Diagrams

#### IOCTL Call-flow during Capturing Images

```mermaid

flowchart TD
A([Start])
id1[Open the image device file]
id2[Obtain the device function of the image file]
id3[Setup and get the image format of the image device]
id4[Apply for buffer VIDIOC_REQBUFS]
id5[Buffer mapped VIDIOC_QUERYBUF]
id6[Paste the buffer into the enqueue VIDIOC_QBUF]
id7[Start capturing the images VIDIOC_STREAMON]
id8[Take the dequeue buffer data VIDIOC_DQBUF]
id9[Paste the buffer into the enqueue VIDIOC_QBUF]
id10{Run or Stop}
id11[Stop capturing images VIDIOC_STREAMOFF]
B([Stop])

A-->id1-->id2-->id3-->id4-->id5-->id6-->id7-->id8-->id9-->id10
id10--N-->id7
id10--Y-->id11-->B

```

#### General IOCTL Call-flow

```mermaid

sequenceDiagram
participant Caller
participant SoC V4L2 Driver

Caller-->>SoC V4L2 Driver: Opening video device file
SoC V4L2 Driver-->>Caller: open() success

Note right of Caller: to check if device is multiplane and support both capture & output buffertype(ie: device is M2M) 
Caller->>SoC V4L2 Driver: VIDIOC_QUERYCAP
SoC V4L2 Driver-->>Caller: return device capabilities

Note right of Caller: To query about the controls available​: <br/> V4L2_CID_MIN_BUFFERS_FOR_CAPTURE <br/> V4L2_CID_MIN_BUFFERS_FOR_OUTPUT
Caller->>SoC V4L2 Driver: VIDIOC_QUERYCTRL​
SoC V4L2 Driver-->>Caller: returns minimum number of buffers
Caller->>SoC V4L2 Driver:to set private  controls
SoC V4L2 Driver-->>Caller:returns 0 on successful operation

Note right of Caller: to enumerate all image formats supported by the driver
Caller->>SoC V4L2 Driver: VIDIOC_ENUM_FMT
SoC V4L2 Driver-->>Caller: returns information on supported image formats.

Note right of Caller: to enumerate the frame size associated with each pixel format
Caller->>SoC V4L2 Driver: VIDIOC_ENUM_FRAMESIZES
SoC V4L2 Driver-->>Caller: returns frame sizes corresponding to each format

Note right of Caller: to get the supported image format
Note right of Caller: for encoded data use: V4L2_BUF_TYPE_VIDEO_OUTPUT/ V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE  
Note right of Caller: for decoded data use: V4L2_BUF_TYPE_VIDEO_CAPTURE/ V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE
Caller->>SoC V4L2 Driver: VIDIOC_G_FMT
SoC V4L2 Driver-->>Caller: returns current supported image formats

Note right of Caller: to set the pixel format such as: <br/>V4L2_PIX_FMT_H264 (input) <br/> V4L2_PIX_FMT_NV12 (output)
Caller->>SoC V4L2 Driver: VIDIOC_S_FMT
SoC V4L2 Driver-->>Caller:returns 0 on setting the image format

Note right of Caller: to request driver the number of input/output buffers to allocate frames
Caller->>SoC V4L2 Driver: VIDIOC_REQBUF
SoC V4L2 Driver-->>Caller: returns number of actual allocated buffer

Note right of Caller: to know the buffer status
Caller->>SoC V4L2 Driver: VIDIOC_QUERYBUF
SoC V4L2 Driver-->>Caller: returns current status of buffer 

rect rgb(191, 225, 255)
loop Caller requests the driver to enqueue each frame
Note right of Caller: to enqueue the buffer
Caller->>SoC V4L2 Driver: VIDIOC_QBUF
Note over SoC V4L2 Driver:all buffers are queued before<br/>starting the video streaming
SoC V4L2 Driver->>Caller:returns 0 on successful operation
end
end

Note right of Caller:Caller starts the acquisition chain
Caller->>SoC V4L2 Driver: VIDIOC_STREAMON
SoC V4L2 Driver->>Caller:returns 0 on successful operation

rect rgb(191, 225, 255)
loop main streaming loop
Note right of Caller: to dequeue the buffer
Caller->>SoC V4L2 Driver: VIDIOC_DQBUF
SoC V4L2 Driver->>Caller:returns 0 on successful operation
SoC V4L2 Driver--)Caller:an uncompressed frame is ready
Note over SoC V4L2 Driver:VIDIOC_DQBUF/QBUF mechanism is <br/>repeated to get each frame sequentially
Caller-->>Caller:get the frame data
Note right of Caller: to re-enqueue the buffer
Caller->>SoC V4L2 Driver: VIDIOC_QBUF
SoC V4L2 Driver->>Caller:returns 0 on successful operation
end
end

Note right of Caller: Caller stops the acquisition with this IOCTL
Caller->>SoC V4L2 Driver: VIDIOC_STREAMOFF
SoC V4L2 Driver->>Caller: returns 0 on successful operation

rect rgb(255,250,225)
Note left of Caller:ready to pause state
Note right of Caller:subscribe to V4L2 events
Caller->>SoC V4L2 Driver: VIDIOC_SUBSCRIBE_EVENT
SoC V4L2 Driver->>Caller: returns 0 on successful operation
Note right of Caller: subscribed events are dequeued using VIDIOC_DQEVENT ioctl
Caller->>SoC V4L2 Driver: VIDIOC_DQEVENT
SoC V4L2 Driver-->>SoC V4L2 Driver: source change or EOS event triggered
SoC V4L2 Driver->>Caller: returns 0 on successful operation
Note left of Caller:when playback stops
Note right of Caller: unsubscribe V4L2 event
Caller->>SoC V4L2 Driver: VIDIOC_UNSUBSCRIBE_EVENT
SoC V4L2 Driver-->>SoC V4L2 Driver: unsubscribe all event
SoC V4L2 Driver->>Caller: returns 0 on successful operation
end

Caller-->>SoC V4L2 Driver: Closing video device file
SoC V4L2 Driver-->>Caller: close() success

```